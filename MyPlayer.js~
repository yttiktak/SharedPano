// MyPlayer.js 
// expects skinBase skinSrc and loadMe to be set from php
// depends on pano2vr_player.js
// depends on pusher.js
// depends on ParkingLotPush.js
// depends on skin.js or definition of pano2vrSkin
// extends pano2vrPlayer
// extends pano2vrSkin
// Roberta Jane Bennett 5/15/16

if (typeof skinSrc == 'undefined') {
  console.log('skin source not defined');
  skinSrc = 'skin.js';
}
if (typeof skinBase == 'undefined') {
  console.log('skin base not defined');
  skinBase = '';
}
if (typeof loadMe == 'undefined') {
  loadMe = 'ParkingLotx.xml';
  console.log('loadMe not defined');
}

var lastloc = {'pan':0,'tilt':0,'yaw':0,'fov':0};
var locHist = [];
function surrogateCtor() {}
function extend(base,sub) {
	surrogateCtor.prototype = base.prototype;
	sub.prototype = new surrogateCtor();
	sub.prototype.constructor = sub;
}
// also use above method to extend existing skin, so I can add the lead/follow flag and other chat.

function MyPlayer( container ) {
// NEED TO HANDLE OTHER HOT SPOT EFFECTS, PARTICULARLY THE IMAGE POP-UPS
	pano2vrPlayer.apply(this,arguments);
	this.readConfigUrlAsync = function( url ) {// these read things do not seem to see action. Except this first one.
		console.log("UrlAsync: "+url); pano2vrPlayer.prototype.readConfigUrlAsync.call(this,url);
	}
	this.readConfigUrl = function( url ) {console.log("Url: "+url); pano2vrPlayer.prototype.readConfigUrl.call(this,url);}
	this.readConfigXml = function( url ) {console.log("Xml: "+url); pano2vrPlayer.prototype.readConfigXml.call(this,url);}	

	this.openUrl = function( url, target ) {	// is called from skin.js on a hotspot click
		console.log("OpenUrl: " +url + " target: " + target);

		if (!target.match(/^pushed /)) { // pushed is my flag for a change that came from a broadcast)
			if (typeof channel !== 'undefined') { { // test, because maybe the channel isnt opened yet, or pusher failed some other way.
				console.log("sending: " +url + " target: pushed " + target);
				var triggered = channel.trigger('client-teleport',{'uri':url,'target':'pushed '+target});
				// why do I catch the return value here, just to ignore it?
			}
		}
		target = target.replace(/^pushed /,'');

		if (url.match(/^http.*/)) {
		// so, outsiders get sent to me as a query string, but if back to self, just as is.
			if (!url.match(/ParkingLotPush\.php/i)) { // Oughta identify self url, not hard code it like this.
				url = url.replace(/(^http.*)/i,'?url=$1');
// SANITIZE THIS URL PLEASE
			}
			var timid = setTimeout(function() { window.location.href=url; },50);
			// Mystery. Was pusher killing the teleport event when I quit the page too early?

/*** here is what happens when a teleport is received by somone else (mind, there may be no one to receive)
	channel.bind('client-teleport',function(data) {
		var triggered = channel.trigger('client-ack',{'event':'teleport','data':data});
		pano.openUrl(data.uri,data.target); });
***/

			return; // It needs this return, or it seemed to get to the pano load (when I was doing straight out set).. hmm.
			// maybe exit or something, even better??
			// script should stop here, as the window is re-loaded. Any worries about pending timeouts ??
		}
		// if using a foreign xml file, 
		//  if an url to an xml, need to run it through my proxy readyXml
		//   eg, otherSpot.xml, Pano2/pano.xml so on
		//  if a node, eg {23}, just pass it through, it refers to the current xml file

		// should do an if(skinBase !== "") ahead of this,but no need, its blank, right??
		if (!url.match(/^{.*}$/i)) {
			url = skinBase + url;
			console.log('skinBased url is now: '+url);
		}
		pano2vrPlayer.prototype.openUrl.call(this,url,target);
	}
}
extend(pano2vrPlayer,MyPlayer); 
			
function MySkin( player, base ) {
	pano2vrSkin.apply(this,arguments);
	// now I can attach my lead/follow and other chat to the current skin
	this.addFlag=function() {
		this._leadingflag=document.createElement('div');
		this._leadingflag__text=document.createElement('div');
		this._leadingflag.className='ggskin ggskin_textdiv';
		this._leadingflag.ggTextDiv=this._leadingflag__text;
		this._leadingflag.ggId="LeadingFlag";
		this._leadingflag.ggParameter={ rx:0,ry:0,a:0,sx:1,sy:1 };
		this._leadingflag.ggVisible=true;
		this._leadingflag.className='ggskin ggskin_text ';
		this._leadingflag.ggType='text';
		this._leadingflag.setAttribute('id','bj-lead-follow');
		hs ='';
		hs+='height : 52px;';
		hs+='left : -98px;';
		hs+='position : absolute;';
		hs+='top : 6px;';
		hs+='visibility : inherit;';
		hs+='width : 91px;';
		this._leadingflag.setAttribute('style',hs);
		// domTransform was defined in this object, so added this. here.
		this._leadingflag.style[this.domTransform + 'Origin']='50% 50%';
		hs ='position:absolute;';
		hs+='left: 0px;';
		hs+='top:  0px;';
		hs+='width: 91px;';
		hs+='height: 52px;';
		hs+='background: #ffffff;';
		hs+='border: 1px solid #000000;';
		hs+='color: #000000;';
		hs+='text-align: center;';
		hs+='white-space: nowrap;';
		hs+='padding: 0px 1px 0px 1px;';
		hs+='overflow: hidden;';
		hs+='overflow-y: auto;';
		this._leadingflag__text.setAttribute('style',hs);
		this._leadingflag__text.innerHTML="Lead/Follow";
		this._leadingflag.appendChild(this._leadingflag__text);
		// changed me to thisfor these
		this._leadingflag.ggIsActive=function() {
			if ((this.parentNode) && (this.parentNode.ggIsActive)) {
				return this.parentNode.ggIsActive();
			}
			return false;
		}
		this._leadingflag.ggElementNodeId=function() {
			if ((this.parentNode) && (this.parentNode.ggElementNodeId)) {
				return this.parentNode.ggElementNodeId();
			}
			return me.player.getCurrentNode();
		}
		this._leadingflag.ggUpdatePosition=function () {
		}
		this._controller.appendChild(this._leadingflag);
	}
	this.addFlag();
}
extend(pano2vrSkin,MySkin);

pano=new MyPlayer("container");

if (typeof pano2vrSkin !=='undefined') {
  // If falling back on my skin, do not use their base url.
  skin = new MySkin(pano,(skinSrc !== "skin.js")?skinBase:""); // skin = new pano2vrSkin(pano); should behave same as if skinBase = '';
}
		

	
var selfTest = false;	
var traj= [];
var lastLoc = {'pan':0,'tilt':0,'yaw':0,'fov':0,'time':0};
var leading = false;
var timeoutid = 0;
var leadFollowDiv = skin.findElements('LeadingFlag')[0];
leadFollowDiv.ggTextDiv.innerText = (leading)?"LEADING0":"following0";


var takeLead = function( lead, offer = false ) {
	// signal to user they are leading the tour or not
	leadFollowDiv.ggTextDiv.innerText = (lead)?((offer)?"ready":"LEADING"):"following";
	leading = lead;
}
timeoutid = setTimeout( function() { takeLead( true); }, (selfTest)?600:15000); 
// if nothing happening 15 sec after load, I start to lead.

var goto = function( cord ) {
	// That last number is speed, seems to be inverse seconds?
	pano.moveTo(cord.pan,cord.tilt,cord.fov,2);
}
var unwrap = function() { // need to compute delay times based on recorded times.
	if (traj.length == 0 ) return;
	var cord = traj.shift();
	goto(cord);
	if (traj.length == 0 ) return;
	var delt = traj[0].time - cord.time;
	window.setTimeout(unwrap,(selfTest)?10000:delt);
}
window.setInterval(function () {
	if (!leading) return;
        panval = pano.getPan();
	tiltval = pano.getTilt();
	yawval = pano.getRoll(); 
	fovval = pano.getFov();
	var d = new Date();
	time = d.getTime();
	if ((lastLoc.pan!==panval)|(lastLoc.tilt!==tiltval)|(lastLoc.yaw!==yawval)|(lastLoc.fov!==fovval)) {
		lastLoc =  {'pan':panval,'tilt':tiltval,'yaw':yawval,'fov':fovval,'time':time};
		locHist.push(lastLoc);// watch out. Pushed by reference. Saved, cause above disconnects.
	}
}, (selfTest)?3000:100);

window.setInterval(function () {

	if (!leading) {
		locHist = [];
		return;
	}
	takeLead( true,true);
	if (locHist.length == 0) return;
	if (typeof channel !== 'undefined') {
		channel.trigger('client-traj',{'id':'needs work','traj':locHist});
	}
	if (selfTest) {
		traj = locHist.slice(0);
		unwrap();
		takeLead(false);
	}
	locHist = [];
}, (selfTest)?12000:2000);

// window.addEventListener("load", function() {

	pano.readConfigUrlAsync(loadMe);// loadMe is injected via PHP, from query string or just ParkingLotx.xml

console.log("subscribe");
var pusher = new Pusher('95b5a3122e42176dd240', {
	encrypted: true,
	authEndpoint: '../_php/pusher_auth.php' // allows anything
});
var channel = pusher.subscribe('private-channel');
	channel.bind('pusher:subscription_succeeded',function() {
	var triggered = channel.trigger('client-arrived',{'where':'somewhere'});
	console.log('subscription ok');
});
console.log("subscribed");
if (typeof channel !== 'undefined') {
	channel.bind('client-traj',function(data) {
		if (leading) {
			takeLead( false);
		}
		if (timeoutid != 0 ) { clearTimeout(timeoutid); }
		timeoutid = setTimeout( function() { takeLead( true,false); }, 5000);

		console.log('new trajectory');
		traj = data.traj.slice(0);
		console.log(traj);
		unwrap();
	});
// SOMETHIGN WRONG WITH TELEPORT TO GARNERVILLE
	channel.bind('client-teleport',function(data) {
		// var triggered = channel.trigger('client-ack',{'event':'teleport','data':data});
		console.log('teleport');
		console.log(data);
		pano.openUrl(data.uri,data.target);
	});
	channel.bind('client-ack',function(data) {
		
	});


channel.bind('pusher:subscription_error',function(status) {
	console.log('subscription error event');
	console.log(status);
});

} // channel bindings 




